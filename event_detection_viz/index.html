<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.5/leaflet.css" />


    <script src="http://cdn.leafletjs.com/leaflet-0.5/leaflet-src.js"></script>
    <script src="http://d3js.org/d3.v3.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/lodash.js/1.0.0-rc.3/lodash.underscore.min.js"></script>

    <script type="text/javascript" src="./js/colorbrewer.js"></script>
    <script type="text/javascript" src="./js/leaflet.points-layer.js"></script>

    <style type="text/css">
      html, body { 
        margin: 0;
        padding: 0;
        height: 100%;
      }

      #map { 
        height: 600px;
        width: 100%;
        margin-bottom: 1em;
      }

      .leaflet-popup-content ul { padding-left: 1.5em; }

      .circle { visibility: hidden; }
      .circle.selected { visibility: visible; }
      .legend {
    line-height: 18px;
    color: #555;
    }
    .legend i {
        width: 18px;
        height: 18px;
        float: left;
        margin-right: 8px;
        opacity: 0.7;
    }

      svg {
        font: 10px sans-serif;
      }


      .axis path, .axis line {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
      }

    </style>
  </head>
  <body>
    <div id='map' data-source="../data/event_detection_2010.json"></div>

    <script type="text/javascript">

        var nb_category_legend = 6; //5 categories


        //focusing swiss on SVG
        var coordinates_center = [46.948927005132,7.4074140555507];
        var extent, scale,
            classes = 9, scheme_id = "BuPu",
            reverse = false;
            scheme = colorbrewer[scheme_id][classes],
            container = L.DomUtil.get('map'),
            map = L.map(container).setView(coordinates_center, 8);

// Choose map layer : https://leaflet-extras.github.io/leaflet-providers/preview/
        L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '<a href="http://content.stamen.com/dotspotting_toner_cartography_available_for_download">Stamen Toner</a>, <a href="http://www.openstreetmap.org/">OpenStreetMap</a>, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>',
            maxZoom: 10
        }).addTo(map);

    function getColor(d,min,max) {
        array = getGradient(min,max);

         return  d >= array[nb_category_legend-2] ? '#800026' :
                  d >= array[nb_category_legend-3]  ? '#BD0026' :
                  d >= array[nb_category_legend-4]   ? '#E31A1C' :
                   d >= array[nb_category_legend-5]  ? '#FC4E2A' :
                              '#FD8D3C';
        }


        function getGradient(min,max) {
            array = []
            array[0] = min-1;
            array[nb_category_legend-1] = max+1
            length = array[nb_category_legend-1] - array[0];

            for (i=1 ; i<nb_category_legend-1; i++) {
                array[i] = array[0] + length/(nb_category_legend-1) * i
            }
            return array;
        }



        function getMax(data) {
            return data[0]["properties"]["max_std"];
        }

        function getMin(data) {
            return data[0]["properties"]["min_std"]
        }

        d3.json(container.dataset.source, function(error, data) {

            maximum_legend = getMax(data.features);
            minimum_legend = getMin(data.features);

            var legend = L.control({position: 'bottomright'});
            legend.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'info legend'),
                grades = getGradient(minimum_legend, maximum_legend)
                console.log(grades)
            // loop through our density intervals and generate a label with a colored square for each interval
            for (var i = 0; i < grades.length-1; i++) {
                div.innerHTML +=
                    '<i style="background:' + getColor(grades[i] , minimum_legend, maximum_legend) + '"></i> ' +
                    grades[i] + ('&ndash;' + grades[i + 1] + '<br>' );
            }
            return div;
        };

        legend.addTo(map);
        });




    (function () {
        d3.json(container.dataset.source, function(collection) {
            L.pointsLayer(collection, {
                radius: get_radius,
                applyStyle: circle_style
                //style: style
            }).addTo(map);

            var chart = timeseries_chart(scheme)
                    .x(get_time).xLabel("Event time")
                    .y(get_nb_tweets).yLabel("Number of tweets per event")
                    .brushmove(on_brush);

            d3.select("body").datum(collection.features).call(chart);

        });
    

        function get_time(d) {
            return d3.time.format.iso.parse(d.properties.dayOfTweet);
        }

        function get_nb_tweets(d) {
            return d.properties.usersPerHashtag;
        }

        function on_brush(brush) {
            var s = brush.extent();
            d3.selectAll(".circle").classed("selected", function (d) {
                var time = get_time(d);
                return s[0] <= time && time <= s[1];
            });
        }

        function get_radius(d) {
            return d.properties.usersPerHashtag * d.properties.usersPerHashtag;
        }

        function circle_style(circles) {
            if (!(extent && scale)) {
                extent = d3.extent(circles.data(), function (d) { return d.properties.std_metrics; });
                scale = d3.scale.log()
                        .domain(reverse ? extent.reverse() : extent)
                        .range(d3.range(classes));
            }
            circles.attr('opacity', 0.4)
                .attr('stroke', scheme[classes - 1])
                .attr('stroke-width', 1)
                .attr('fill', function (d) {
                   return getColor(d.properties.std_metrics, d.properties.min_std, d.properties.max_std);
                });
                //TODO look the different attr of the circles


            circles.on('click', function (d, i) {
                L.DomEvent.stopPropagation(d3.event);

                var t = '<ul>' +
                        '<li>Hashtag: <%- hashtag %></li>' +
                        '<li>Std: <%- std_metrics %></li>' +
                        '</ul>';

                var data = {
                        hashtag: d.properties.hashtag,
                        std_metrics: d.properties.std_metrics.toFixed(2)
                    };

                L.popup()
                    .setLatLng([d.geometry.coordinates[1], d.geometry.coordinates[0]])
                    .setContent(_.template(t, data))
                    .openOn(map);

            });
            
        }



        function timeseries_chart(color) {

            var margin = { top: 5, right: 5, bottom: 40, left: 55 },
                width =  600 - margin.left - margin.right,
                height = 120;

            var x = d3.time.scale(),
                y = d3.scale.linear(),
                x_label = "X", y_label = "Y",
                brush = d3.svg.brush().x(x).on("brush", _brushmove);

            var get_x = no_op,
                get_y = no_op;

            function timeseries(selection) {
                selection.each(function (d) {
                    x.range([0, width]);
                    y.range([height, 0]);

                    var series = d3.select(this).append("svg").attr("id", "tweets-timeseries")
                            .attr("width", width + margin.left + margin.right)
                            .attr("height", height + margin.top + margin.bottom)
                            .append("g").attr("id", "date-brush")
                            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

                    var x_axis = series.append("g")
                            .attr("class", "x axis")
                            .attr("transform", "translate(0," + height + ")");

                    var y_axis = series.append("g")
                            .attr("class", "y axis");

                    x_axis.append("text")
                        .attr("class", "label")
                        .attr("x", width)
                        .attr("y", 30)
                        .style("text-anchor", "end")
                        .style("font-weight","bold")
                        .text(x_label);

                    y_axis.append("text")
                        .attr("class", "label")
                        .attr("transform", "rotate(-90)")
                        .attr("y", -50)
                        .attr("dy", ".71em")
                        .style("text-anchor", "end")
                        .style("font-weight","bold")
                        .text(y_label);

                    series.append("clipPath")
                        .attr("id", "clip")
                        .append("rect")
                        .attr("width", width - 1)
                        .attr("height", height - .25)
                        .attr("transform", "translate(1,0)");

                    series.append("g")
                            .attr("class", "brush")
                            .call(brush)
                            .selectAll("rect")
                            .attr("height", height)
                            .style("stroke-width", 1)
                            .style("stroke", color[color.length - 1])
                            .style("fill", color[2])
                            .attr("opacity", 0.4);

                    x.domain(d3.extent(d, get_x));
                    x_axis.call(d3.svg.axis().scale(x).orient("bottom"));

                    y.domain(d3.extent(d, get_y));
                    y_axis.call(d3.svg.axis().scale(y).orient("left"));

                    series.append("g").attr("class", "timeseries")
                        .attr("clip-path", "url(#clip)")
                        .selectAll("circle")
                        .data(d).enter()
                        .append("circle")
                        .style("stroke", color[color.length - 2])
                        .style("stroke-width", .5)
                        .style("fill", color[color.length - 1])
                        .attr("opacity", .4)
                        .attr("r", 2)
                        .attr("transform", function (d) {
                            return "translate(" + x(get_x(d)) + "," + y(get_y(d)) + ")";
                        });
                });
            }

            timeseries.x = function (accessor) {
                if (!arguments.length) return get_x;
                get_x = accessor;
                return timeseries;
            };

            timeseries.y = function (accessor) {
                if (!arguments.length) return get_y;
                get_y = accessor;
                return timeseries;
            };

            timeseries.xLabel = function (label) {
                if (!arguments.length) return x_label;
                x_label = label;
                return timeseries;
            }

            timeseries.yLabel = function (label) {
                if (!arguments.length) return y_label;
                y_label = label;
                return timeseries;
            }

            timeseries.brushmove = function (cb) {
                if (!arguments.length) return brushmove;
                brushmove = cb;
                return timeseries;
            };

            function _brushmove() {
                brushmove.call(null, brush);
            }

            function no_op() {}

            return timeseries;
        }
    }());
    </script>
  </body>
</html>